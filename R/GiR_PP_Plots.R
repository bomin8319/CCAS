#' @title Make Nice GiR PP-Plots
#' @description Makes Nice PP Plots with Getting it Right Results.
#'
#' @param forward_samples A dataframe with statistic generated by
#' test_internal_functions() with Getting_It_Right = TRUE.
#' @param backward_samples A dataframe with statistic generated by
#' test_internal_functions() with Getting_It_Right = TRUE.
#' @return A bunch of plots.
#' @export
GiR_PP_Plots <- function(forward_samples,
                         backward_samples) {
    UMASS_BLUE <- rgb(51,51,153,155,maxColorValue = 255)
    UMASS_RED <- rgb(153,0,51,155,maxColorValue = 255)
    UMASS_GREEN <- rgb(0,102,102,255,maxColorValue = 255)
    UMASS_YELLOW <- rgb(255,255,102,255,maxColorValue = 255)
    UMASS_ORANGE <- rgb(255,204,51,255,maxColorValue = 255)

    nms <- colnames(forward_samples)

    for (i in 1:ncol(forward_samples)) {
        cat("Generating Plot",i,"of",ncol(forward_samples),"\n")
        all <- c(backward_samples[,i],forward_samples[,i])
        ylims <- c(min(all)-0.1*(max(abs(all))),
                   max(all)+0.1*(max(abs(all))))
        xlims <- ylims
        qqplot(x = quantile(forward_samples[,i],seq(0,1,length=1000)),
               y = quantile(backward_samples[,i],seq(0,1,length=1000)),
               ylim = ylims,
               xlim = xlims,
               ylab = "Backward",
               xlab = "Forward",
               col = UMASS_BLUE,
               pch = 19,
               main = nms[i],
               cex.lab=2,
               cex.axis=1.4,
               cex.main=2)
        lines(x = xlims, y= ylims,
              col = UMASS_RED,lwd = 3)
        text(paste( "Backward Mean:", round(mean(backward_samples[,i]),4),
                    "\nForward Mean:", round(mean(forward_samples[,i]),4),
                    "\nt-test p-value:",
                    round(t.test(backward_samples[,i],
                                 forward_samples[,i])$p.value,4),
                    "\nMann-Whitney p-value:",
                    round(wilcox.test(backward_samples[,i],
                                      forward_samples[,i])$p.value,4)),
             x = xlims[2] - 0.3*abs(xlims[2] - xlims[1]),
             y = ylims[1] + 0.2*abs(ylims[2] - ylims[1]),
             cex = 1.5)
    }
}

